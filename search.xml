<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象的拖拽 第二种]]></title>
    <url>%2F2017%2F05%2F06%2Fdrag2%2F</url>
    <content type="text"><![CDATA[面向对象的拖拽dom 元素运动1.改变top left2.translate 不会引起页面重绘 获取transform兼容写法123456789101112131415// 获取transform兼容写法 function getTransform()&#123; var transform = &apos;&apos;, divStyle = document.createElement(&apos;div&apos;).style, transformArr =[&apos;transform&apos;,&apos;webkitTransform&apos;,&apos;MozTransform&apos;,&apos;msTransfrom&apos;,&apos;OTransform&apos;], i = 0, len = transformArr.length; for(;i&lt;len;i++)&#123; if(transformArr[i] in divStyle)&#123; return transform = transformArr[i]; &#125; &#125; return transform; &#125; 获取元素的样式属性1234function getStyle(elem,property)&#123; //ie通过currentStyle 其他通过getComputedStyle return document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(elem,false)[property]:elem.currentStyle[property];&#125; 获取元素的当前位置12345678910111213141516171819202122232425262728function getTargetPos(elem)&#123; var pos = &#123;x:0,y:0&#125;; var transform = getTransform(); if(transform)&#123; var transformValue = getStyle(elem,transform); if(transformValue == &apos;none&apos;)&#123; elem.style[transform] = &apos;translate(0,0)&apos;; return pos; &#125;else&#123; var temp = transformValue.match(/-?\d+/g); return pos = &#123; x:parseInt(temp[4].trim()), y:parseInt(temp[5].trim()) &#125; &#125; &#125;else&#123; if(getStyle(elem,&apos;position&apos;) == &apos;static&apos;)&#123; elem.style.position = &apos;relative&apos;; return pos; &#125;else&#123; var x = parseInt(getStyle(elem,&apos;left&apos;)?getStyle(elem,&apos;left&apos;):0); var y = parseInt(getStyle(elem,&apos;top&apos;)?getStyle(elem,&apos;top&apos;):0); return pos = &#123; x:x, y:y &#125; &#125; &#125; &#125; 设置元素位置12345678910function setTargetPos(elem,pos)&#123; var transform =getTransform(); if(transform)&#123; elem.style[transform] = 'translate('+pos.x+'px,'+pos.y+'px)'; &#125;else&#123; elem.style.left = pos.x +'px'; elem.style.top = pos.y +'px'; &#125; return elem;&#125; 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131(function() &#123; // 这是一个私有属性，不需要被实例访问 var transform = getTransform(); function Drag(selector) &#123; // 放在构造函数中的属性，都是属于每一个实例单独拥有 this.elem = typeof selector == 'Object' ? selector : document.getElementById(selector); this.startX = 0; this.startY = 0; this.sourceX = 0; this.sourceY = 0; this.init(); &#125; // 原型 Drag.prototype = &#123; constructor: Drag, init: function() &#123; // 初始时需要做些什么事情 this.setDrag(); &#125;, // 稍作改造，仅用于获取当前元素的属性，类似于getName getStyle: function(property) &#123; return document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(this.elem, false)[property] : this.elem.currentStyle[property]; &#125;, // 用来获取当前元素的位置信息，注意与之前的不同之处 getPosition: function() &#123; var pos = &#123;x: 0, y: 0&#125;; if(transform) &#123; var transformValue = this.getStyle(transform); if(transformValue == 'none') &#123; this.elem.style[transform] = 'translate(0, 0)'; &#125; else &#123; var temp = transformValue.match(/-?\d+/g); pos = &#123; x: parseInt(temp[4].trim()), y: parseInt(temp[5].trim()) &#125; &#125; &#125; else &#123; if(this.getStyle('position') == 'static') &#123; this.elem.style.position = 'relative'; &#125; else &#123; pos = &#123; x: parseInt(this.getStyle('left') ? this.getStyle('left') : 0), y: parseInt(this.getStyle('top') ? this.getStyle('top') : 0) &#125; &#125; &#125; return pos; &#125;, // 用来设置当前元素的位置 setPostion: function(pos) &#123; if(transform) &#123; this.elem.style[transform] = 'translate('+ pos.x +'px, '+ pos.y +'px)'; &#125; else &#123; this.elem.style.left = pos.x + 'px'; this.elem.style.top = pos.y + 'px'; &#125; &#125;, // 该方法用来绑定事件 setDrag: function() &#123; var self = this; this.elem.addEventListener('mousedown', start, false); function start(event) &#123; self.startX = event.pageX; self.startY = event.pageY; var pos = self.getPosition(); self.sourceX = pos.x; self.sourceY = pos.y; document.addEventListener('mousemove', move, false); document.addEventListener('mouseup', end, false); &#125; function move(event) &#123; var currentX = event.pageX; var currentY = event.pageY; var distanceX = currentX - self.startX; var distanceY = currentY - self.startY; self.setPostion(&#123; x: (self.sourceX + distanceX).toFixed(), y: (self.sourceY + distanceY).toFixed() &#125;) &#125; function end(event) &#123; document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', end); // do other things &#125; &#125; &#125; // 私有方法，仅仅用来获取transform的兼容写法 function getTransform() &#123; var transform = '', divStyle = document.createElement('div').style, transformArr = ['transform', 'webkitTransform', 'MozTransform', 'msTransform', 'OTransform'], i = 0, len = transformArr.length; for(; i &lt; len; i++) &#123; if(transformArr[i] in divStyle) &#123; return transform = transformArr[i]; &#125; &#125; return transform; &#125; // 一种对外暴露的方式 window.Drag = Drag; &#125;)(); // 使用：声明2个拖拽实例 new Drag('target'); new Drag('target2');]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的拖拽 第一种]]></title>
    <url>%2F2017%2F05%2F06%2Fdrag%2F</url>
    <content type="text"><![CDATA[html对拖拽对象添加 position:absolute; 面向对象的拖拽js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Drag()&#123; this.obj = null; this.disX = 0; this.disY = 0; this.settings = &#123; //默认参数 toDown : function()&#123;&#125;, toUp : function()&#123;&#125; &#125;; &#125;Drag.prototype.init = function(opt)&#123; var This = this; this.obj = document.getElementById(opt.id); extend( this.settings , opt ); this.obj.onmousedown = function(ev)&#123; var ev = ev || window.event; This.fnDown(ev); This.settings.toDown(); document.onmousemove = function(ev)&#123; var ev = ev || window.event; This.fnMove(ev); &#125;; document.onmouseup = function()&#123; This.fnUp(); This.settings.toUp(); &#125;; return false;//阻止默认事件 &#125;;&#125;;Drag.prototype.fnDown = function(ev)&#123; this.disX = ev.clientX - this.obj.offsetLeft; this.disY = ev.clientY - this.obj.offsetTop;&#125;;Drag.prototype.fnMove = function(ev)&#123; this.obj.style.left = ev.clientX - this.disX + 'px'; this.obj.style.top = ev.clientY - this.disY + 'px';&#125;;Drag.prototype.fnUp = function()&#123; document.onmousemove = null; document.onmouseup = null;&#125;;function extend(obj1,obj2)&#123; for(var attr in obj2)&#123; obj1[attr] = obj2[attr]; &#125;&#125; 调用12345678var d2 = new Drag();d2.init(&#123; //配置参数 id : &apos;div2&apos;, toDown : function()&#123; document.title = &apos;hello&apos;; document.body.style.background = &apos;black&apos;; &#125;&#125;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[search框的css写法]]></title>
    <url>%2F2017%2F05%2F06%2Fsearch%2F</url>
    <content type="text"><![CDATA[今天看了一个搜索栏的网页，简单研究下使用div form 包裹input 和button html代码如下123456&lt;div class="search bar1"&gt; &lt;form action=""&gt; &lt;input type="text" placeholder="shuru"&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 对原样式进行清除123456*&#123;box-sizing: border-box;margin: 0;padding: 0;&#125;.search&#123;padding: 30px 0;&#125;form&#123;position: relative;width: 300px;margin: 0 auto;&#125;input,button&#123;border: none;outline: none;&#125;input&#123;width: 300px;height: 42px;padding-left: 13px&#125;button&#123;height: 42px;width: 62px;cursor: pointer;position: absolute;&#125; 设置样式123456789.bar1&#123;background:#a3d0c3;&#125;.bar1 input&#123;border:2px solid #7ba7ab;border-radius:5px;background: #f9f0da;color:#9e9c9c;&#125;.bar1 button&#123;top: 0;right: 0;background: #7ba7ab;border-radius: 0 5px 5px 0;&#125;.bar1 button:before&#123; content:"\f002";/*此处引入了fontawesome的css*/ font-family: FontAwesome; font-size: 16px; color:black;&#125; 引入 font-awesome &lt;link href=&quot;http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 源码地址https://github.com/dankan108/webpage-collect/blob/master/search/searchbar.html 截图]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[马克飞象]]></title>
    <url>%2F2017%2F05%2F05%2Fwode%2F</url>
    <content type="text"><![CDATA[欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#x68;&#x75;&#x73;&#x74;&#x67;&#x6f;&#x63;&#x6b;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>